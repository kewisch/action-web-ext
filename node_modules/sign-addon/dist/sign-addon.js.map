{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"common-tags\"","webpack:///external \"fs\"","webpack:///external \"path\"","webpack:///external \"mz\"","webpack:///external \"url\"","webpack:///external \"deepcopy\"","webpack:///external \"jsonwebtoken\"","webpack:///external \"request\"","webpack:///./src/PseudoProgress.js","webpack:///./src/amo-client.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","PseudoProgress","constructor","_clearInterval","clearInterval","_setInterval","setInterval","preamble","stdout","process","this","interval","motionCounter","bucket","emptyBucketPointers","setPreamble","addendum","shellWidth","isTTY","Number","columns","bucketSize","length","push","animate","animateConfig","conf","speed","bucketIsFull","moveBucket","randomlyFillBucket","finish","fillBucket","write","randomIndex","Math","floor","random","showBucket","isFull","newPointers","forEach","pointer","map","join","formatResponse","response","overrides","options","_stringifyToJson","JSON","stringify","maxLength","prettyResponse","e","substring","toString","Client","apiKey","apiSecret","apiUrlPrefix","apiJwtExpiresIn","debugLogging","statusCheckInterval","statusCheckTimeout","logger","console","downloadDir","cwd","fs","defaultFs","request","defaultRequest","proxyServer","requestConfig","progressBar","_progressBar","_fs","_request","sign","guid","version","channel","xpiPath","formData","upload","createReadStream","addonUrl","httpMethod","put","encodeURIComponent","debug","post","warn","url","throwOnBadResponse","then","httpResponse","body","receivedError","error","indexOf","statusCode","Promise","resolve","success","id","downloadedFiles","errorCode","errorDetails","Error","absoluteURL","headers","waitForSignedAddon","statusUrl","_clearTimeout","clearTimeout","_setAbortTimeout","setTimeout","_setStatusCheckTimeout","lastStatus","reject","abortTimeout","oneLine","checkSignedStatus","async","status","canBeAutoSigned","automated_signing","signedAndReady","valid","active","reviewed","files","requiresManualReview","log","result","downloadSignedFiles","err","checkValidationStatus","processed","validation_url","signedFiles","createWriteStream","allDownloads","dataExpected","dataReceived","showProgress","progress","amount","toFixed","padding","Array","download","fileUrl","fileName","path","absUrl","basename","parse","split","out","configureRequest","method","followRedirect","on","contentLength","parseInt","chunk","pipe","foundUnsignedFiles","file","signed","download_url","all","replace","requestConf","patch","delete","urlString","match","config","jwt","defaultJwt","String","proxy","authToken","iss","algorithm","expiresIn","timeout","Authorization","Accept","toLowerCase","toUpperCase","requestMethod","responseBody","args","arguments","val","newVal","deepcopy","redact","obj","hdr","keys","signAddon","verbose","apiProxy","apiRequestConfig","AMOClient","DefaultAMOClient","reportEmpty","stat","isFile","statError","signAddonAndExit","systemProcess","throwError","exit","stack"],"mappings":"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","file":"sign-addon.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","module.exports = require(\"common-tags\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"mz\");","module.exports = require(\"url\");","module.exports = require(\"deepcopy\");","module.exports = require(\"jsonwebtoken\");","module.exports = require(\"request\");","/**\n * @typedef {{\n *   isTTY: boolean;\n *   columns: number;\n *   write: (buffer: string) => boolean;\n * }} Stdout\n */\n\n/**\n * A pseudo progress indicator.\n *\n * This is just a silly shell animation that was meant to simulate how lots of\n * tests would be run on an add-on file. It sort of looks like a torrent file\n * randomly getting filled in.\n */\nclass PseudoProgress {\n  /**\n   * @typedef {object} PseudoProgressParams\n   * @property {string=} preamble\n   * @property {typeof clearInterval=} _clearInterval\n   * @property {Stdout=} stdout\n   * @property {typeof setInterval=} _setInterval\n   *\n   * @param {PseudoProgressParams} params\n   */\n  constructor({\n    _clearInterval = clearInterval,\n    _setInterval = setInterval,\n    preamble = '',\n    stdout = process.stdout,\n  } = {}) {\n    this.interval = null;\n    this.motionCounter = 1;\n\n    this.setInterval = _setInterval;\n    this.clearInterval = _clearInterval;\n    this.stdout = stdout;\n\n    /** @type {string[]} */\n    this.bucket = [];\n    /** @type {number[]} */\n    this.emptyBucketPointers = [];\n\n    this.setPreamble(preamble);\n  }\n\n  /**\n   * @param {string} preamble\n   */\n  setPreamble(preamble) {\n    this.preamble = `${preamble} [`;\n    this.addendum = ']';\n\n    let shellWidth = 80;\n    if (this.stdout.isTTY) {\n      shellWidth = Number(this.stdout.columns);\n    }\n\n    this.emptyBucketPointers = [];\n    this.bucket = [];\n\n    const bucketSize = shellWidth - this.preamble.length - this.addendum.length;\n    for (let i = 0; i < bucketSize; i++) {\n      this.bucket.push(' ');\n      this.emptyBucketPointers.push(i);\n    }\n  }\n\n  /**\n   * @typedef {object} AnimateConfig\n   * @property {number} speed\n   *\n   * @param {AnimateConfig=} animateConfig\n   */\n  animate(animateConfig) {\n    const conf = {\n      speed: 100,\n      ...animateConfig,\n    };\n    let bucketIsFull = false;\n    this.interval = this.setInterval(() => {\n      if (bucketIsFull) {\n        this.moveBucket();\n      } else {\n        bucketIsFull = this.randomlyFillBucket();\n      }\n    }, conf.speed);\n  }\n\n  finish() {\n    if (this.interval) {\n      this.clearInterval(this.interval);\n    }\n\n    this.fillBucket();\n    // The bucket has already filled to the terminal width at this point\n    // but for copy/paste purposes, add a new line:\n    this.stdout.write('\\n');\n  }\n\n  randomlyFillBucket() {\n    // randomly fill a bucket (the width of the shell) with dots.\n    const randomIndex = Math.floor(\n      Math.random() * this.emptyBucketPointers.length,\n    );\n    this.bucket[this.emptyBucketPointers[randomIndex]] = '.';\n\n    this.showBucket();\n\n    let isFull = true;\n    /** @type {number[]} */\n    const newPointers = [];\n    this.emptyBucketPointers.forEach((pointer) => {\n      if (this.bucket[pointer] === ' ') {\n        isFull = false;\n        newPointers.push(pointer);\n      }\n    });\n    this.emptyBucketPointers = newPointers;\n\n    return isFull;\n  }\n\n  fillBucket() {\n    // fill the whole bucket with dots to indicate completion.\n    this.bucket = this.bucket.map(function () {\n      return '.';\n    });\n    this.showBucket();\n  }\n\n  moveBucket() {\n    // animate dots moving in a forward motion.\n    for (let i = 0; i < this.bucket.length; i++) {\n      this.bucket[i] = (i - this.motionCounter) % 3 ? ' ' : '.';\n    }\n    this.showBucket();\n\n    this.motionCounter++;\n  }\n\n  showBucket() {\n    this.stdout.write(\n      `\\r${this.preamble}${this.bucket.join('')}${this.addendum}`,\n    );\n  }\n}\n\nexport default PseudoProgress;\n","/* eslint max-classes-per-file: 0 */\nimport defaultFs from 'fs';\nimport url from 'url';\nimport path from 'path';\n\nimport deepcopy from 'deepcopy';\nimport defaultJwt from 'jsonwebtoken';\nimport defaultRequest from 'request';\nimport { oneLine } from 'common-tags';\n\nimport PseudoProgress from './PseudoProgress';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n\n/** @typedef {import(\"request\").Response} Response */\n\n/**\n * @typedef {\"listed\" | \"unlisted\"} ReleaseChannel\n */\n\n/**\n * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#checking-the-status-of-your-upload\n *\n * @typedef {{\n *   guid: string,\n *   active: boolean,\n *   automated_signing: boolean,\n *   files: File[],\n *   passed_review: boolean,\n *   pk: string,\n *   processed: boolean,\n *   reviewed: boolean,\n *   url: string,\n *   valid: boolean,\n *   validation_results: object,\n *   validation_url: string,\n *   version: string,\n * }} SigningStatus\n */\n\n/**\n * @typedef {object} ClientParams\n * @property {string} apiKey - API key string from the Developer Hub\n * @property {string} apiSecret - API secret string from the Developer Hub\n * @property {string} apiUrlPrefix - API URL prefix, including any leading paths\n * @property {number=} apiJwtExpiresIn - Number of seconds until the JWT token for the API request expires. This must match the expiration time that the API server accepts\n * @property {boolean=} debugLogging - When true, log more information\n * @property {number=} statusCheckInterval - A period in millesconds between checks when waiting on add-on status\n * @property {number=} statusCheckTimeout -  A length in millesconds to give up if the add-on hasn't been validated and signed\n * @property {typeof console=} logger\n * @property {string=} downloadDir - Absolute path to save downloaded files to. The working directory will be used by default\n * @property {typeof defaultFs=} fs\n * @property {typeof defaultRequest=} request\n * @property {string=} proxyServer - Optional proxy server to use for all requests, such as \"http://yourproxy:6000\"\n * @property {RequestConfig=} requestConfig - Optional configuration object to pass to request(). Not all parameters are guaranteed to be applied\n * @property {PseudoProgress=} progressBar\n */\n\n/**\n * @typedef {object} SignParams\n * @property {string=} guid - optional add-on GUID (ID in install.rdf)\n * @property {string} version - add-on version string\n * @property {ReleaseChannel=} channel - release channel (listed or unlisted)\n * @property {string} xpiPath - path to xpi file\n */\n\n/**\n * @typedef {(\"SERVER_FAILURE\"|\"ADDON_NOT_AUTO_SIGNED\"|\"VALIDATION_FAILED\")} SignErrorCode\n */\n\n/**\n * @typedef {{\n *   success: boolean,\n *   id: string | null,\n *   downloadedFiles: string[] | null,\n *   errorCode: SignErrorCode | null,\n *   errorDetails: string | null\n * }} SignResult\n */\n\n/**\n * Returns a nicely formatted HTTP response.\n * This makes the response suitable for logging.\n *\n * @param {string|object} response - either the response's body or an object representing a JSON API response.\n * @param {object=} overrides\n * @returns {string}\n */\nexport function formatResponse(response, overrides = {}) {\n  const options = {\n    _stringifyToJson: JSON.stringify,\n    maxLength: 500,\n    ...overrides,\n  };\n  let prettyResponse = response;\n  const stringify = options._stringifyToJson || JSON.stringify;\n  if (typeof prettyResponse === 'object') {\n    try {\n      prettyResponse = stringify(prettyResponse);\n    } catch (e) {\n      //\n    }\n  }\n  if (typeof prettyResponse === 'string') {\n    if (prettyResponse.length > options.maxLength) {\n      prettyResponse = `${prettyResponse.substring(0, options.maxLength)}...`;\n    }\n  }\n  return prettyResponse.toString();\n}\n\n/**\n * Returns the basename of a URL, suitable for saving to disk.\n *\n * @param {string} absUrl\n * @returns {string}\n */\nexport function getUrlBasename(absUrl) {\n  // TODO: `url.parse()` might return `undefined` so we need to check that first.\n  // @ts-ignore\n  const urlPath = path.basename(url.parse(absUrl).path);\n  const parts = urlPath.split('?');\n\n  return parts[0];\n}\n/**\n * addons.mozilla.org API client.\n */\nexport class Client {\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {object} RequestMethodOptions\n   * @property {boolean=} throwOnBadResponse - if true, an error will be thrown when response status is not 2xx\n   */\n\n  /**\n   * Type for `this.request()`.\n   *\n   * @typedef {Promise<[Response, SigningStatus]>} RequestMethodReturnValue\n   */\n\n  /**\n   * See: https://addons-server.readthedocs.io/en/latest/topics/api/signing.html#get--api-v4-addons-(string-guid)-versions-(string-version)-[uploads-(string-upload-pk)-]\n   *\n   * @typedef {{ signed: boolean, download_url: string, hash: string }} File\n   */\n\n  /**\n   * @param {ClientParams} params\n   */\n  constructor({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    // TODO: put this back to something sane after we\n    // address the file upload issue on AMO:\n    // https://github.com/mozilla/addons-server/issues/3688\n    apiJwtExpiresIn = 60 * 5, // 5 minutes\n    debugLogging = false,\n    statusCheckInterval = 1000,\n    statusCheckTimeout = 900000, // 15 minutes.\n    logger = console,\n    downloadDir = process.cwd(),\n    fs = defaultFs,\n    request = defaultRequest,\n    proxyServer,\n    requestConfig,\n    progressBar,\n  }) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.apiUrlPrefix = apiUrlPrefix; // default set in CLI options.\n    this.apiJwtExpiresIn = apiJwtExpiresIn;\n    this.statusCheckInterval = statusCheckInterval;\n    this.statusCheckTimeout = statusCheckTimeout;\n    this.debugLogging = debugLogging;\n    this.logger = logger;\n    this.downloadDir = downloadDir;\n    this.proxyServer = proxyServer;\n    this.requestConfig = requestConfig || {};\n\n    // Set up external dependencies, allowing for overrides.\n    this._progressBar =\n      progressBar ||\n      new PseudoProgress({\n        preamble: 'Validating add-on',\n      });\n    this._fs = fs;\n    this._request = request;\n  }\n\n  /**\n   * Sign a new version of your add-on at addons.mozilla.org.\n   *\n   * @param {SignParams} signParams\n   * @returns {Promise<SignResult>}\n   */\n  sign({ guid, version, channel, xpiPath }) {\n    /**\n     * @type {{\n     *   upload: defaultFs.ReadStream;\n     *   channel?: string;\n     *   version?: string;\n     * }}\n     */\n    const formData = {\n      upload: this._fs.createReadStream(xpiPath),\n    };\n    let addonUrl = '/addons/';\n    let httpMethod = this.put;\n    if (guid) {\n      // PUT to a specific URL for this add-on + version.\n      addonUrl += `${encodeURIComponent(guid)}/versions/${encodeURIComponent(\n        version,\n      )}/`;\n      if (channel) {\n        formData.channel = channel;\n      }\n    } else {\n      // POST to a generic URL to create a new add-on.\n      this.debug('Signing add-on without an ID');\n      httpMethod = this.post;\n      formData.version = version;\n      if (channel) {\n        this.logger.warn(\n          'Specifying a channel for a new add-on is unsupported. ' +\n            'New add-ons are always in the unlisted channel.',\n        );\n      }\n    }\n\n    return httpMethod\n      .bind(this)(\n        {\n          url: addonUrl,\n          formData,\n        },\n        {\n          throwOnBadResponse: false,\n        },\n      )\n      .then(\n        /**\n         * @param {[\n         *   Response,\n         *   { error?: string, headers?: {[name: string]: string}, url: string }\n         * ]} requestValue\n         * @returns {Promise<SignResult>} result\n         */\n        ([httpResponse, body]) => {\n          const response = body;\n\n          const acceptableStatuses = [200, 201, 202];\n          const receivedError = !!response.error;\n          if (\n            acceptableStatuses.indexOf(httpResponse.statusCode) === -1 ||\n            receivedError\n          ) {\n            if (response.error) {\n              this.logger.error(\n                `Server response: ${response.error}`,\n                `(status: ${httpResponse.statusCode})`,\n              );\n              return Promise.resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'SERVER_FAILURE',\n                errorDetails: response.error,\n              });\n            }\n\n            throw new Error(\n              `Received bad response from the server while requesting ${this.absoluteURL(\n                addonUrl,\n              )}\\n\\n` +\n                `status: ${httpResponse.statusCode}\\n` +\n                `response: ${formatResponse(response)}\\n` +\n                `headers: ${JSON.stringify(httpResponse.headers || {})}\\n`,\n            );\n          }\n\n          return this.waitForSignedAddon(response.url);\n        },\n      );\n  }\n\n  /**\n   * Poll a status URL, waiting for the queued add-on to be signed.\n   *\n   * @typedef {object} WaitForSignedAddonParams\n   * @property {typeof clearTimeout=} _clearTimeout\n   * @property {typeof setTimeout=} _setAbortTimeout\n   * @property {typeof setTimeout=} _setStatusCheckTimeout\n   *\n   * @param {string} statusUrl - URL to GET for add-on status\n   * @param {WaitForSignedAddonParams} options\n   * @returns {Promise<SignResult>}\n   */\n  waitForSignedAddon(\n    statusUrl,\n    {\n      _clearTimeout = clearTimeout,\n      _setAbortTimeout = setTimeout,\n      _setStatusCheckTimeout = setTimeout,\n    } = {},\n  ) {\n    /** @type {SigningStatus=} */\n    let lastStatus;\n\n    return new Promise((resolve, reject) => {\n      /** @type {NodeJS.Timer} */\n      let statusCheckTimeout;\n\n      /** @type {NodeJS.Timer} */\n      const abortTimeout = _setAbortTimeout(() => {\n        this._progressBar.finish();\n        _clearTimeout(statusCheckTimeout);\n\n        reject(\n          new Error(oneLine`Signing took too long to complete; last status:\n            ${formatResponse(lastStatus || '[null]')}`),\n        );\n      }, this.statusCheckTimeout);\n\n      // This function polls the API until the add-on is signed or requires\n      // manual review. If the add-on is signed, we download the signed files.\n      //\n      // This function resolves the main `Promise` in both cases.\n      const checkSignedStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          lastStatus = status;\n\n          const canBeAutoSigned = status.automated_signing;\n          // The add-on passed validation and all files have been created. There\n          // are many checks for this state because the data will be updated\n          // incrementally by the API server.\n          const signedAndReady =\n            status.valid &&\n            status.active &&\n            status.reviewed &&\n            status.files &&\n            status.files.length > 0;\n          // The add-on is valid but requires a manual review before it can be\n          // signed.\n          const requiresManualReview = status.valid && !canBeAutoSigned;\n\n          if (signedAndReady || requiresManualReview) {\n            this._progressBar.finish();\n            _clearTimeout(abortTimeout);\n\n            if (requiresManualReview) {\n              this.logger.log(oneLine`Your add-on has been submitted for review.\n              It passed validation but could not be automatically signed\n              because this is a listed add-on.`);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'ADDON_NOT_AUTO_SIGNED',\n                errorDetails: null,\n              });\n              return;\n            }\n\n            if (signedAndReady) {\n              // TODO: show some validation warnings if there are any. We should\n              // show things like \"missing update URL in manifest\"\n              const result = await this.downloadSignedFiles(status.files);\n              resolve({ ...result, id: status.guid });\n            }\n          } else {\n            // The add-on has not been fully processed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkSignedStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // This function polls the API until the add-on is processed/validated.\n      // This function only rejects when the add-on is not valid. When the\n      // add-on is valid, we call `checkSignedStatus()`.\n      const checkValidationStatus = async () => {\n        try {\n          const [\n            // eslint-disable-next-line no-unused-vars\n            httpResponse,\n            status,\n          ] = await this.get({ url: statusUrl });\n          lastStatus = status;\n\n          if (status.processed) {\n            this._progressBar.finish();\n            this.logger.log('Validation results:', status.validation_url);\n            // Update pseudo progress preamble for the signing step.\n            this._progressBar.setPreamble('Signing add-on');\n            this._progressBar.animate();\n\n            if (status.valid) {\n              checkSignedStatus();\n            } else {\n              this.logger.log(\n                'Your add-on failed validation and could not be signed',\n              );\n\n              _clearTimeout(abortTimeout);\n\n              resolve({\n                success: false,\n                id: null,\n                downloadedFiles: null,\n                errorCode: 'VALIDATION_FAILED',\n                errorDetails: status.validation_url,\n              });\n            }\n          } else {\n            // Validation is not completed yet.\n            statusCheckTimeout = _setStatusCheckTimeout(\n              checkValidationStatus,\n              this.statusCheckInterval,\n            );\n          }\n        } catch (err) {\n          _clearTimeout(abortTimeout);\n          reject(err);\n        }\n      };\n\n      // Goooo\n      this._progressBar.animate();\n      checkValidationStatus();\n    });\n  }\n\n  /**\n   * Download the signed files.\n   *\n   * @param {File[]} signedFiles - Array of file objects returned from the API.\n   * @param {{\n   *   createWriteStream?: typeof defaultFs.createWriteStream,\n   *   request?: typeof defaultRequest,\n   *   stdout?: typeof process.stdout\n   * }} options\n   * @returns {Promise<SignResult>}\n   */\n  async downloadSignedFiles(\n    signedFiles,\n    {\n      createWriteStream = defaultFs.createWriteStream,\n      request = this._request,\n      stdout = process.stdout,\n    } = {},\n  ) {\n    /** @type {Promise<string>[]} */\n    const allDownloads = [];\n    /** @type {null | number} */\n    let dataExpected = null;\n    let dataReceived = 0;\n\n    function showProgress() {\n      let progress = '...';\n      if (dataExpected !== null) {\n        const amount = ((dataReceived / dataExpected) * 100).toFixed();\n        // Pad the percentage amount so that the line length is consistent.\n        // This should do something like '  0%', ' 25%', '100%'\n        let padding = '';\n        try {\n          padding = Array(4 - amount.length).join(' ');\n        } catch (e) {\n          // Ignore Invalid array length and such.\n        }\n        progress = `${padding + amount}% `;\n      }\n      stdout.write(`\\rDownloading signed files: ${progress}`);\n    }\n\n    /**\n     * @param {string} fileUrl\n     * @returns {Promise<string>}\n     */\n    const download = (fileUrl) => {\n      return new Promise((resolve, reject) => {\n        // The API will give us a signed file named in a sane way.\n        const fileName = path.join(this.downloadDir, getUrlBasename(fileUrl));\n        const out = createWriteStream(fileName);\n\n        request(\n          this.configureRequest({\n            method: 'GET',\n            url: fileUrl,\n            followRedirect: true,\n          }),\n        )\n          .on('error', reject)\n          .on(\n            'response',\n            /**\n             * @param {Response} response\n             * @returns {void}\n             */\n            (response) => {\n              if (response.statusCode < 200 || response.statusCode >= 300) {\n                throw new Error(\n                  `Got a ${response.statusCode} response ` +\n                    `when downloading ${fileUrl}`,\n                );\n              }\n              const contentLength = response.headers['content-length'];\n              if (contentLength) {\n                if (dataExpected !== null) {\n                  dataExpected += parseInt(contentLength, 10);\n                } else {\n                  dataExpected = parseInt(contentLength, 10);\n                }\n              }\n            },\n          )\n          .on(\n            'data',\n            /**\n             * @param {string} chunk\n             * @returns {void}\n             */\n            (chunk) => {\n              dataReceived += chunk.length;\n              showProgress();\n            },\n          )\n          .pipe(out)\n          .on('error', reject);\n\n        out.on('finish', function () {\n          stdout.write('\\n'); // end the progress output\n          resolve(fileName);\n        });\n      });\n    };\n\n    let foundUnsignedFiles = false;\n    signedFiles.forEach((file) => {\n      if (file.signed) {\n        allDownloads.push(download(file.download_url));\n      } else {\n        this.debug('This file was not signed:', file);\n\n        foundUnsignedFiles = true;\n      }\n    });\n\n    let downloadedFiles;\n    if (allDownloads.length) {\n      if (foundUnsignedFiles) {\n        this.logger.log(oneLine`Some files were not signed. Re-run with\n        --verbose for details.`);\n      }\n\n      showProgress();\n\n      downloadedFiles = await Promise.all(allDownloads);\n    } else {\n      throw new Error(oneLine`The XPI was processed but no signed files were\n      found. Check your manifest and make sure it targets Firefox as an\n      application.`);\n    }\n\n    this.logger.log('Downloaded:');\n    downloadedFiles.forEach((fileName) => {\n      this.logger.log(`    ${fileName.replace(process.cwd(), '.')}`);\n    });\n\n    return {\n      success: true,\n      id: null,\n      downloadedFiles,\n      errorCode: null,\n      errorDetails: null,\n    };\n  }\n\n  /**\n   * Make a GET request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  get(requestConf, options) {\n    return this.request('get', requestConf, options);\n  }\n\n  /**\n   * Make a POST request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  post(requestConf, options) {\n    return this.request('post', requestConf, options);\n  }\n\n  /**\n   * Make a PUT request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  put(requestConf, options) {\n    return this.request('put', requestConf, options);\n  }\n\n  /**\n   * Make a PATCH request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  patch(requestConf, options) {\n    return this.request('patch', requestConf, options);\n  }\n\n  /**\n   * Make a DELETE request.\n   *\n   * @param {RequestConfig} requestConf\n   * @param {RequestMethodOptions=} options\n   * @returns {RequestMethodReturnValue}\n   */\n  delete(requestConf, options) {\n    return this.request('delete', requestConf, options);\n  }\n\n  /**\n   * Returns a URL that is guaranteed to be absolute.\n   *\n   * @param {string} urlString - a relative or already absolute URL\n   * @returns {string} url - an absolute URL, prefixed by the API prefix if necessary.\n   */\n  absoluteURL(urlString) {\n    if (!urlString.match(/^http/i)) {\n      return this.apiUrlPrefix + urlString;\n    }\n\n    return urlString;\n  }\n\n  /**\n   * Configures a request with defaults such as authentication headers.\n   *\n   * @param {RequestConfig} config - as accepted by the `request` module\n   * @param {{ jwt?: typeof defaultJwt}} options\n   * @returns {RequestConfig}\n   */\n  configureRequest(config, { jwt = defaultJwt } = {}) {\n    const requestConf = {\n      ...this.requestConfig,\n      ...config,\n    };\n\n    if (!requestConf.url) {\n      throw new Error('request URL was not specified');\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.url = this.absoluteURL(String(requestConf.url));\n\n    if (this.proxyServer) {\n      // eslint-disable-next-line no-param-reassign\n      requestConf.proxy = this.proxyServer;\n    }\n\n    const authToken = jwt.sign({ iss: this.apiKey }, this.apiSecret, {\n      algorithm: 'HS256',\n      expiresIn: this.apiJwtExpiresIn,\n    });\n\n    // Make sure the request won't time out before the JWT expires.\n    // This may be useful for slow file uploads.\n    // eslint-disable-next-line no-param-reassign\n    requestConf.timeout = this.apiJwtExpiresIn * 1000 + 500;\n\n    // eslint-disable-next-line no-param-reassign\n    requestConf.headers = {\n      Authorization: `JWT ${authToken}`,\n      Accept: 'application/json',\n      ...requestConf.headers,\n    };\n\n    return requestConf;\n  }\n\n  /**\n   * Make any HTTP request to the addons.mozilla.org API.\n   *\n   * This includes the necessary authorization header.\n   *\n   * The returned promise will be resolved with an array of arguments that\n   * match the arguments sent to the callback as specified in the `request`\n   * module.\n   *\n   * @param {string} httpMethod - HTTP method name.\n   * @param {RequestConfig} config - options accepted by the `request` module\n   * @param {RequestMethodOptions} options\n   * @returns {RequestMethodReturnValue}\n   */\n  async request(httpMethod, config, { throwOnBadResponse = true } = {}) {\n    const method = httpMethod.toLowerCase();\n    const requestConf = this.configureRequest(config);\n\n    let [\n      // eslint-disable-next-line prefer-const\n      httpResponse,\n      body,\n    ] = await new Promise((resolve, reject) => {\n      this.debug(`[API] ${method.toUpperCase()} request:\\n`, requestConf);\n\n      // Get the caller, like request.get(), request.put() ...\n      // @ts-ignore\n      const requestMethod = this._request[method].bind(this._request);\n      // Wrap the request callback in a promise. Here is an example without\n      // promises:\n      //\n      // request.put(requestConf, function(err, httpResponse, body) {\n      //   // promise gets resolved here\n      // })\n      requestMethod(\n        /** @type RequestConfig */\n        requestConf,\n        /**\n         * @param {Error} error\n         * @param {Response} response\n         * @param {string} responseBody\n         */\n        (error, response, responseBody) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve([response, responseBody]);\n        },\n      );\n    });\n\n    if (throwOnBadResponse) {\n      if (httpResponse.statusCode > 299 || httpResponse.statusCode < 200) {\n        throw new Error(\n          `Received bad response from ${this.absoluteURL(\n            String(requestConf.url),\n          )}; ` +\n            `status: ${httpResponse.statusCode}; ` +\n            `response: ${formatResponse(body)}`,\n        );\n      }\n    }\n\n    if (\n      httpResponse.headers &&\n      httpResponse.headers['content-type'] === 'application/json' &&\n      typeof body === 'string'\n    ) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        this.logger.log('Failed to parse JSON response from server:', e);\n      }\n    }\n\n    this.debug(\n      `[API] ${method.toUpperCase()} response:\\n`,\n      `Status: ${httpResponse.statusCode}\\n`,\n      { headers: httpResponse.headers, response: body },\n    );\n\n    return [httpResponse, body];\n  }\n\n  /**\n   * Output some debugging info if this instance is configured for it.\n   */\n  debug() {\n    if (!this.debugLogging) {\n      return;\n    }\n\n    /**\n     * @param {{ headers: {[key: string]: string} } & {[prop: string]: any}} obj\n     */\n    function redact(obj) {\n      if (typeof obj !== 'object' || !obj) {\n        return obj;\n      }\n      if (obj.headers) {\n        ['Authorization', 'cookie', 'set-cookie'].forEach(function (hdr) {\n          if (obj.headers[hdr]) {\n            // eslint-disable-next-line no-param-reassign\n            obj.headers[hdr] = '<REDACTED>';\n          }\n        });\n      }\n\n      Object.keys(obj).forEach(function (key) {\n        // eslint-disable-next-line no-param-reassign\n        obj[key] = redact(obj[key]);\n      });\n\n      return obj;\n    }\n\n    // TODO: remove the use of `arguments`\n    // eslint-disable-next-line prefer-rest-params\n    const args = Array.prototype.map.call(arguments, function (val) {\n      let newVal = val;\n      if (typeof newVal === 'object') {\n        newVal = deepcopy(newVal);\n        newVal = redact(newVal);\n      }\n      return newVal;\n    });\n    this.logger.log('[sign-addon]', ...args);\n  }\n}\n","import { fs } from 'mz';\n\nimport { Client as DefaultAMOClient } from './amo-client';\n\n/** @typedef {import(\"request\").OptionsWithUrl} RequestConfig */\n/** @typedef {import(\"./amo-client\").ClientParams} ClientParams */\n/** @typedef {import(\"./amo-client\").ReleaseChannel} ReleaseChannel */\n\n/**\n * @typedef {object} SignAddonParams\n * @property {string} xpiPath\n * @property {string} id\n * @property {string} version\n * @property {ClientParams['apiKey']} apiKey\n * @property {ClientParams['apiSecret']} apiSecret\n * @property {ClientParams['apiUrlPrefix']=} apiUrlPrefix\n * @property {ClientParams['apiJwtExpiresIn']=} apiJwtExpiresIn\n * @property {ClientParams['debugLogging']=} verbose\n * @property {ReleaseChannel=} channel\n * @property {ClientParams['statusCheckTimeout']=} timeout\n * @property {ClientParams['downloadDir']=} downloadDir\n * @property {ClientParams['proxyServer']=} apiProxy\n * @property {ClientParams['requestConfig']=} apiRequestConfig\n * @property {typeof DefaultAMOClient=} AMOClient\n *\n * @param {SignAddonParams} params\n */\nconst signAddon = async ({\n  // Absolute path to add-on XPI file.\n  xpiPath,\n  // The add-on ID as recognized by AMO. Example: my-addon@jetpack\n  id,\n  // The add-on version number for AMO.\n  version,\n  // Your API key (JWT issuer) from AMO Devhub.\n  apiKey,\n  // Your API secret (JWT secret) from AMO Devhub.\n  apiSecret,\n  // Optional arguments:\n  apiUrlPrefix = 'https://addons.mozilla.org/api/v4',\n  // Number of seconds until the JWT token for the API request expires.\n  // This must match the expiration time that the API server accepts.\n  apiJwtExpiresIn,\n  verbose = false,\n  // The release channel (listed or unlisted).\n  // Ignored for new add-ons, which are always unlisted.\n  // Defaults to most recently used channel.\n  channel,\n  // Number of milliseconds to wait before giving up on a\n  // response from Mozilla's web service.\n  timeout,\n  // Absolute directory to save downloaded files in.\n  downloadDir,\n  // Optional proxy to use for all API requests,\n  // such as \"http://yourproxy:6000\"\n  apiProxy,\n  // Optional object to pass into request() for additional configuration.\n  // Not all properties are guaranteed to be applied.\n  apiRequestConfig,\n  AMOClient = DefaultAMOClient,\n}) => {\n  /**\n   * @param {string} name\n   */\n  function reportEmpty(name) {\n    throw new Error(`required argument was empty: ${name}`);\n  }\n\n  if (!xpiPath) {\n    reportEmpty('xpiPath');\n  }\n\n  if (!version) {\n    reportEmpty('version');\n  }\n\n  if (!apiSecret) {\n    reportEmpty('apiSecret');\n  }\n\n  if (!apiKey) {\n    reportEmpty('apiKey');\n  }\n\n  try {\n    const stats = await fs.stat(xpiPath);\n\n    if (!stats.isFile) {\n      throw new Error(`not a file: ${xpiPath}`);\n    }\n  } catch (statError) {\n    throw new Error(`error with ${xpiPath}: ${statError}`);\n  }\n\n  const client = new AMOClient({\n    apiKey,\n    apiSecret,\n    apiUrlPrefix,\n    apiJwtExpiresIn,\n    downloadDir,\n    debugLogging: verbose,\n    statusCheckTimeout: timeout,\n    proxyServer: apiProxy,\n    requestConfig: apiRequestConfig,\n  });\n\n  return client.sign({\n    xpiPath,\n    guid: id,\n    version,\n    channel,\n  });\n};\n\n/**\n * @param {SignAddonParams} options\n * @param {{\n *   systemProcess?: typeof process,\n *   throwError?: boolean,\n *   logger?: typeof console\n * }} extras\n * @returns {Promise<void>}\n */\nexport const signAddonAndExit = async (\n  options,\n  { systemProcess = process, throwError = false, logger = console },\n) => {\n  try {\n    const result = await signAddon(options);\n    logger.log(result.success ? 'SUCCESS' : 'FAIL');\n    systemProcess.exit(result.success ? 0 : 1);\n  } catch (err) {\n    logger.error('FAIL');\n\n    if (throwError) {\n      throw err;\n    }\n\n    logger.error(err.stack);\n    systemProcess.exit(1);\n  }\n};\n\nexport default { signAddon, signAddonAndExit };\n"],"sourceRoot":""}