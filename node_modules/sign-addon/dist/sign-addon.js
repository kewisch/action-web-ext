require("source-map-support").install(),module.exports=function(e){var t={};function r(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(s,i,function(t){return e[t]}.bind(null,i));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=8)}([function(e,t){e.exports=require("common-tags")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("mz")},function(e,t){e.exports=require("url")},function(e,t){e.exports=require("deepcopy")},function(e,t){e.exports=require("jsonwebtoken")},function(e,t){e.exports=require("request")},function(e,t,r){"use strict";r.r(t),r.d(t,"signAddonAndExit",(function(){return x}));var s=r(3),i=r(1),o=r.n(i),n=r(4),a=r.n(n),u=r(2),l=r.n(u),h=r(5),c=r.n(h),d=r(6),p=r.n(d),g=r(7),f=r.n(g),m=r(0);var w=class{constructor({_clearInterval:e=clearInterval,_setInterval:t=setInterval,preamble:r="",stdout:s=process.stdout}={}){this.interval=null,this.motionCounter=1,this.setInterval=t,this.clearInterval=e,this.stdout=s,this.bucket=[],this.emptyBucketPointers=[],this.setPreamble(r)}setPreamble(e){this.preamble=e+" [",this.addendum="]";let t=80;this.stdout.isTTY&&(t=Number(this.stdout.columns)),this.emptyBucketPointers=[],this.bucket=[];const r=t-this.preamble.length-this.addendum.length;for(let e=0;e<r;e++)this.bucket.push(" "),this.emptyBucketPointers.push(e)}animate(e){const t={speed:100,...e};let r=!1;this.interval=this.setInterval(()=>{r?this.moveBucket():r=this.randomlyFillBucket()},t.speed)}finish(){this.interval&&this.clearInterval(this.interval),this.fillBucket(),this.stdout.write("\n")}randomlyFillBucket(){const e=Math.floor(Math.random()*this.emptyBucketPointers.length);this.bucket[this.emptyBucketPointers[e]]=".",this.showBucket();let t=!0;const r=[];return this.emptyBucketPointers.forEach(e=>{" "===this.bucket[e]&&(t=!1,r.push(e))}),this.emptyBucketPointers=r,t}fillBucket(){this.bucket=this.bucket.map((function(){return"."})),this.showBucket()}moveBucket(){for(let e=0;e<this.bucket.length;e++)this.bucket[e]=(e-this.motionCounter)%3?" ":".";this.showBucket(),this.motionCounter++}showBucket(){this.stdout.write(`\r${this.preamble}${this.bucket.join("")}${this.addendum}`)}};function y(e,t={}){const r={_stringifyToJson:JSON.stringify,maxLength:500,...t};let s=e;const i=r._stringifyToJson||JSON.stringify;if("object"==typeof s)try{s=i(s)}catch(e){}return"string"==typeof s&&s.length>r.maxLength&&(s=s.substring(0,r.maxLength)+"..."),s.toString()}class b{constructor({apiKey:e,apiSecret:t,apiUrlPrefix:r,apiJwtExpiresIn:s=300,debugLogging:i=!1,statusCheckInterval:n=1e3,statusCheckTimeout:a=9e5,logger:u=console,downloadDir:l=process.cwd(),fs:h=o.a,request:c=f.a,proxyServer:d,requestConfig:p,progressBar:g}){this.apiKey=e,this.apiSecret=t,this.apiUrlPrefix=r,this.apiJwtExpiresIn=s,this.statusCheckInterval=n,this.statusCheckTimeout=a,this.debugLogging=i,this.logger=u,this.downloadDir=l,this.proxyServer=d,this.requestConfig=p||{},this._progressBar=g||new w({preamble:"Validating add-on"}),this._fs=h,this._request=c}sign({guid:e,version:t,channel:r,xpiPath:s}){const i={upload:this._fs.createReadStream(s)};let o="/addons/",n=this.put;return e?(o+=`${encodeURIComponent(e)}/versions/${encodeURIComponent(t)}/`,r&&(i.channel=r)):(this.debug("Signing add-on without an ID"),n=this.post,i.version=t,r&&this.logger.warn("Specifying a channel for a new add-on is unsupported. New add-ons are always in the unlisted channel.")),n.bind(this)({url:o,formData:i},{throwOnBadResponse:!1}).then(([e,t])=>{const r=t,s=!!r.error;if(-1===[200,201,202].indexOf(e.statusCode)||s){if(r.error)return this.logger.error("Server response: "+r.error,`(status: ${e.statusCode})`),Promise.resolve({success:!1,id:null,downloadedFiles:null,errorCode:"SERVER_FAILURE",errorDetails:r.error});throw new Error(`Received bad response from the server while requesting ${this.absoluteURL(o)}\n\nstatus: ${e.statusCode}\nresponse: ${y(r)}\nheaders: ${JSON.stringify(e.headers||{})}\n`)}return this.waitForSignedAddon(r.url)})}waitForSignedAddon(e,{_clearTimeout:t=clearTimeout,_setAbortTimeout:r=setTimeout,_setStatusCheckTimeout:s=setTimeout}={}){let i;return new Promise((o,n)=>{let a;const u=r(()=>{this._progressBar.finish(),t(a),n(new Error(m.oneLine`Signing took too long to complete; last status:
            ${y(i||"[null]")}`))},this.statusCheckTimeout),l=async()=>{try{const[r,n]=await this.get({url:e});i=n;const h=n.automated_signing,c=n.valid&&n.active&&n.reviewed&&n.files&&n.files.length>0,d=n.valid&&!h;if(c||d){if(this._progressBar.finish(),t(u),d)return this.logger.log(m.oneLine`Your add-on has been submitted for review.
              It passed validation but could not be automatically signed
              because this is a listed add-on.`),void o({success:!1,id:null,downloadedFiles:null,errorCode:"ADDON_NOT_AUTO_SIGNED",errorDetails:null});if(c){const e=await this.downloadSignedFiles(n.files);o({...e,id:n.guid})}}else a=s(l,this.statusCheckInterval)}catch(e){t(u),n(e)}},h=async()=>{try{const[r,n]=await this.get({url:e});i=n,n.processed?(this._progressBar.finish(),this.logger.log("Validation results:",n.validation_url),this._progressBar.setPreamble("Signing add-on"),this._progressBar.animate(),n.valid?l():(this.logger.log("Your add-on failed validation and could not be signed"),t(u),o({success:!1,id:null,downloadedFiles:null,errorCode:"VALIDATION_FAILED",errorDetails:n.validation_url}))):a=s(h,this.statusCheckInterval)}catch(e){t(u),n(e)}};this._progressBar.animate(),h()})}async downloadSignedFiles(e,{createWriteStream:t=o.a.createWriteStream,request:r=this._request,stdout:s=process.stdout}={}){const i=[];let n=null,u=0;function h(){let e="...";if(null!==n){const t=(u/n*100).toFixed();let r="";try{r=Array(4-t.length).join(" ")}catch(e){}e=r+t+"% "}s.write("\rDownloading signed files: "+e)}const c=e=>new Promise((i,o)=>{const c=l.a.join(this.downloadDir,(d=e,l.a.basename(a.a.parse(d).path).split("?")[0]));var d;const p=t(c);r(this.configureRequest({method:"GET",url:e,followRedirect:!0})).on("error",o).on("response",t=>{if(t.statusCode<200||t.statusCode>=300)throw new Error(`Got a ${t.statusCode} response when downloading `+e);const r=t.headers["content-length"];r&&(null!==n?n+=parseInt(r,10):n=parseInt(r,10))}).on("data",e=>{u+=e.length,h()}).pipe(p).on("error",o),p.on("finish",(function(){s.write("\n"),i(c)}))});let d,p=!1;if(e.forEach(e=>{e.signed?i.push(c(e.download_url)):(this.debug("This file was not signed:",e),p=!0)}),!i.length)throw new Error(m.oneLine`The XPI was processed but no signed files were
      found. Check your manifest and make sure it targets Firefox as an
      application.`);return p&&this.logger.log(m.oneLine`Some files were not signed. Re-run with
        --verbose for details.`),h(),d=await Promise.all(i),this.logger.log("Downloaded:"),d.forEach(e=>{this.logger.log("    "+e.replace(process.cwd(),"."))}),{success:!0,id:null,downloadedFiles:d,errorCode:null,errorDetails:null}}get(e,t){return this.request("get",e,t)}post(e,t){return this.request("post",e,t)}put(e,t){return this.request("put",e,t)}patch(e,t){return this.request("patch",e,t)}delete(e,t){return this.request("delete",e,t)}absoluteURL(e){return e.match(/^http/i)?e:this.apiUrlPrefix+e}configureRequest(e,{jwt:t=p.a}={}){const r={...this.requestConfig,...e};if(!r.url)throw new Error("request URL was not specified");r.url=this.absoluteURL(String(r.url)),this.proxyServer&&(r.proxy=this.proxyServer);const s=t.sign({iss:this.apiKey},this.apiSecret,{algorithm:"HS256",expiresIn:this.apiJwtExpiresIn});return r.timeout=1e3*this.apiJwtExpiresIn+500,r.headers={Authorization:"JWT "+s,Accept:"application/json",...r.headers},r}async request(e,t,{throwOnBadResponse:r=!0}={}){const s=e.toLowerCase(),i=this.configureRequest(t);let[o,n]=await new Promise((e,t)=>{this.debug(`[API] ${s.toUpperCase()} request:\n`,i);this._request[s].bind(this._request)(i,(r,s,i)=>{r?t(r):e([s,i])})});if(r&&(o.statusCode>299||o.statusCode<200))throw new Error(`Received bad response from ${this.absoluteURL(String(i.url))}; status: ${o.statusCode}; response: `+y(n));if(o.headers&&"application/json"===o.headers["content-type"]&&"string"==typeof n)try{n=JSON.parse(n)}catch(e){this.logger.log("Failed to parse JSON response from server:",e)}return this.debug(`[API] ${s.toUpperCase()} response:\n`,`Status: ${o.statusCode}\n`,{headers:o.headers,response:n}),[o,n]}debug(){if(!this.debugLogging)return;const e=Array.prototype.map.call(arguments,(function(e){let t=e;return"object"==typeof t&&(t=c()(t),t=function e(t){return"object"==typeof t&&t?(t.headers&&["Authorization","cookie","set-cookie"].forEach((function(e){t.headers[e]&&(t.headers[e]="<REDACTED>")})),Object.keys(t).forEach((function(r){t[r]=e(t[r])})),t):t}(t)),t}));this.logger.log("[sign-addon]",...e)}}const v=async({xpiPath:e,id:t,version:r,apiKey:i,apiSecret:o,apiUrlPrefix:n="https://addons.mozilla.org/api/v4",apiJwtExpiresIn:a,verbose:u=!1,channel:l,timeout:h,downloadDir:c,apiProxy:d,apiRequestConfig:p,AMOClient:g=b})=>{function f(e){throw new Error("required argument was empty: "+e)}e||f("xpiPath"),r||f("version"),o||f("apiSecret"),i||f("apiKey");try{if(!(await s.fs.stat(e)).isFile)throw new Error("not a file: "+e)}catch(t){throw new Error(`error with ${e}: ${t}`)}return new g({apiKey:i,apiSecret:o,apiUrlPrefix:n,apiJwtExpiresIn:a,downloadDir:c,debugLogging:u,statusCheckTimeout:h,proxyServer:d,requestConfig:p}).sign({xpiPath:e,guid:t,version:r,channel:l})},x=async(e,{systemProcess:t=process,throwError:r=!1,logger:s=console})=>{try{const r=await v(e);s.log(r.success?"SUCCESS":"FAIL"),t.exit(r.success?0:1)}catch(e){if(s.error("FAIL"),r)throw e;s.error(e.stack),t.exit(1)}};t.default={signAddon:v,signAddonAndExit:x}}]).default;
//# sourceMappingURL=sign-addon.js.map